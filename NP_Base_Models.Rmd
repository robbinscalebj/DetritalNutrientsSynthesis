---
title: "Show_NP"
author: "CJR"
date: "5/18/2022"
output: html_document
---

##Setup and Data Trim
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(gratia)
library(mgcv)
library(tidymv)
library(RColorBrewer)

plot_theme <- theme(panel.grid = element_blank(), 
                    axis.text = element_text(size = 14, face = "bold"),
                    axis.title = element_text(size = 16, face = "bold"),
                    legend.title = element_text(size = 14, face = "bold"),
                    legend.text = element_text(size = 12))

deriv_plot_theme <- theme(axis.text = element_text(size = 14, face = "bold"),
                    axis.title = element_text(size = 16, face = "bold"),
                    legend.title = element_text(size = 14, face = "bold"),
                    legend.text = element_text(size = 12),
                    strip.text.x = element_text(size = 14, face = "bold"),
                    strip.background = element_rect(fill = "#F4F6F6"))

```

```{r data ingest}


det_raw <- read_csv("C:\\Users\\robbi\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")

```



```{r create new summary variables, include=FALSE}
det <- det_raw%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass = ((C_per/100)*Mass_per_remaining),
         N_mass = ((N_per/100)*Mass_per_remaining),
         P_mass = ((P_per/100)*Mass_per_remaining),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*(Mass_per_remaining/100))/((first(N_per)/100)*first(Mass_per_remaining/100)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%


  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


```

```{r trim data}
det_trim<-det%>%
  filter(Mass_per_remaining<=100)%>%
  filter(Mass_per_remaining >=20)%>%
  #filter(N_mass_norm != 0)%>%
  filter(Detritus_Type == "leaves")%>%
  filter(Detritus_Condition == "senesced")%>%
  filter(Remain_Mass_Category == "dm"|Remain_Mass_Category == "afdm")%>%
  filter(mesh_cat != "open")%>%
  mutate(Remain_Mass_Category = fct_drop(Remain_Mass_Category, only = c("dm_postleach", "afdm_postleach", "organic_carbon")))%>%
  mutate(mesh_cat = fct_drop(mesh_cat, "open"))%>%
  ungroup()

levels(det_trim$Remain_Mass_Category)
levels(det_trim$mesh_cat)
levels(det_trim$Lotic_Lentic)

```


```{r create separate lotic-lentic fine-coarse datasets}

det_loc <- det_trim%>%filter(mesh_cat == "coarse", Lotic_Lentic == "Lotic", Remain_Mass_Category == "afdm")
det_loc_cnp <- det_loc%>%filter(CNP_Ratio_Type == "molar")

```




#N mass models
##Base initial N models


```{r Ni curves}



Ni_1 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "identity"),select = TRUE) 

Ni_2 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 


Ni_3 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

Ni_4 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "identity"),select = TRUE) 

Ni_5 <- gam(data = det_loc2, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 


Ni_6 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "log"),select = TRUE) 

map(list(Ni_1, Ni_2, Ni_3, Ni_4, Ni_5, Ni_6), appraise)
AIC(Ni_1, Ni_2, Ni_3, Ni_4, Ni_5, Ni_6)

# Comparisons whether interaction term is needed

Ni_5a <- gam(data = det_loc, N_mass_norm ~  
               ti(Mass_per_loss, m = 2) + ti(initial_N, m = 2)+
                     ti(Mass_per_loss, initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

Ni_5b <- gam(data = det_loc, N_mass_norm ~  
                     ti(Mass_per_loss, m = 2) + ti(initial_N, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

Ni_5c <- gam(data = det_loc, N_mass_norm ~  
                     ti(Mass_per_loss, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

map(list(Ni_5a, Ni_5b), summary)
map(list(Ni_5a, Ni_5b,Ni_5c), AIC) #slightly favors less complex model



Nbase_loc_mod <- Ni_5 #set best model to easier name to remember for later comparisons


#plot predictions
Nbase_loc.pred<-predict_gam(type = "link", Ni_5, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, initial_N = c(3,2,1.5,1.0,0.6,0.3)))%>%
  mutate(initial_N = as_factor(initial_N))


Nbase_loc.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(N_mass_norm)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = Nbase_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
  ylab("Normalized N Mass")+
  xlab("Mass Loss (%)")+
  scale_color_brewer(palette = "Dark2")+
  guides(color=guide_legend(title="Initial N (%)"))+
   theme_bw()+plot_theme+
    NULL
 Nbase_loc.p
 
 


```


```{r N Mass derivs}

N_mass_grid <- expand_grid(Mass_per_loss = seq(0,80, by = 0.2), initial_N = c(0.3,0.6,1.0,1.5,2.0,3), series_index = 578)
n_draws <- 10000
N_mass_grid_exp <- map_dfr(seq_len(n_draws), ~N_mass_grid)


N_gam_fitted <- fitted_samples(Nbase_loc_mod, exclude = "s(series_index,Mass_per_loss", n = n_draws, newdata = N_mass_grid, seed = 1)%>%
  bind_cols(N_mass_grid_exp)%>%mutate(initial_N = as_factor(initial_N), draw = as_factor(draw))


N_deriv_samples <- N_gam_fitted%>%arrange(initial_N)%>%group_by(draw, initial_N)%>%mutate(fit_dif = (fitted-lag(fitted))/0.2)%>%mutate(Mass_per_loss = as_factor(Mass_per_loss))%>%ungroup()%>%
  group_by(initial_N, Mass_per_loss)%>%summarize(md_posterior = median(fit_dif), upper_posterior = quantile(fit_dif,0.975,na.rm = TRUE), lower_posterior = quantile(fit_dif,0.025,na.rm = TRUE))

ggplot(data = N_deriv_samples%>%mutate(Mass_per_loss = as.numeric(as.character(Mass_per_loss)))%>%filter(Mass_per_loss>0))+
         geom_line(aes(x= Mass_per_loss, y = md_posterior), size = 1)+
  geom_line(aes(x= Mass_per_loss, y = lower_posterior), linetype = 2)+
  geom_line(aes(x= Mass_per_loss, y = upper_posterior), linetype = 2)+
         facet_wrap(.~initial_N)+
  ylab("First Derivative (N/Mass loss)")+
  xlab("Mass Loss (%)")+
  geom_hline(yintercept = 0)+
  theme_bw()+deriv_plot_theme+
  NULL

```


#PMass analysis
```{r Pi curves}


Pi_1 <- gam(data = det_loc, P_mass_norm ~  
                        te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "identity"),select = TRUE) 

Pi_2 <- gam(data = det_loc, P_mass_norm ~  
                     te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 


Pi_3 <- gam(data = det_loc, P_mass_norm ~  
                     te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

Pi_4 <- gam(data = det_loc, P_mass_norm ~  
                     te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "identity"),select = TRUE)

Pi_5 <- gam(data = det_loc, P_mass_norm ~  
                     te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"),
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE)


Pi_6 <- gam(data = det_loc, P_mass_norm ~  
                     te(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "log")) 



#model comparison and evaluation
Pi_names<-list(Pi_1,Pi_2,Pi_3,Pi_4,Pi_5,Pi_6) 
map(Pi_names, ~AIC(.)) #best is 5
map(Pi_names, ~appraise(.)) #all are heteroscedastic, with no great options
summary(Pi_5) 

Pi_5a <- gam(data = det_loc, P_mass_norm ~  
               ti(Mass_per_loss, m = 2) + ti(initial_P, m = 2)+
                     ti(Mass_per_loss, initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

Pi_5b <- gam(data = det_loc, P_mass_norm ~  
                     ti(Mass_per_loss, m = 2) + ti(initial_P, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

Pi_5c <- gam(data = det_loc, P_mass_norm ~  
                     ti(Mass_per_loss, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

map(list(Pi_5a, Pi_5b), summary) #interaction term pval = 0.0014
map(list(Pi_5a, Pi_5b,Pi_5c), AIC) #AIC favors second model


Pbase_loc_mod <- Pi_5  #set best model to easier name to remember for later comparisons


#plot predictions
Pbase_loc.pred<-predict_gam(type = "link", Pbase_loc_mod, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_P = c(0.01,0.02,0.05,0.1,0.15,0.23)))%>%
  mutate(Initial_P = as_factor(initial_P))


 Pbase_loc.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(P_mass_norm)), aes(Mass_per_loss, P_mass_norm), alpha = 0.3)+
    geom_smooth(data = Pbase_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Initial_P))+
    geom_abline(slope = -0.01, intercept = 1)+
   scale_color_brewer(palette = ("Dark2"))+
   guides(color=guide_legend(title="Initial P (%)"))+
   xlab("Mass Loss (%)")+
   ylab("Normalized P mass")+
   theme_bw()+plot_theme+
    NULL
 Pbase_loc.p

```

```{r P mass derivs}
P_mass_grid <- expand_grid(Mass_per_loss = seq(0,80, by = 0.2), initial_P = c(0.01,0.02,0.05,0.1,0.15,0.23), series_index = 578)
n_draws <- 10000
P_mass_grid_exp <- map_dfr(seq_len(n_draws), ~P_mass_grid)


P_gam_fitted <- fitted_samples(Pbase_loc_mod, exclude = "s(series_index,Mass_per_loss", n = n_draws, newdata = P_mass_grid, seed = 1)%>%
  bind_cols(P_mass_grid_exp)%>%mutate(initial_P = as_factor(initial_P), draw = as_factor(draw))


P_deriv_samples <- P_gam_fitted%>%arrange(initial_P)%>%group_by(draw, initial_P)%>%mutate(fit_dif = (fitted-lag(fitted))/0.2)%>%mutate(Mass_per_loss = as_factor(Mass_per_loss))%>%ungroup()%>%
  group_by(initial_P, Mass_per_loss)%>%summarize(md_posterior = median(fit_dif), upper_posterior = quantile(fit_dif,0.975,na.rm = TRUE), lower_posterior = quantile(fit_dif,0.025,na.rm = TRUE))

ggplot(data = P_deriv_samples%>%mutate(Mass_per_loss = as.numeric(as.character(Mass_per_loss)))%>%filter(Mass_per_loss>0))+
         geom_line(aes(x= Mass_per_loss, y = md_posterior), size = 1)+
  geom_line(aes(x= Mass_per_loss, y = lower_posterior), linetype = 2)+
  geom_line(aes(x= Mass_per_loss, y = upper_posterior), linetype = 2)+
         facet_wrap(.~initial_P)+
  geom_hline(yintercept = 0)+
  ylab("First Derivative (P/Mass loss)")+
  xlab("Mass Loss (%)")+
  theme_bw()+deriv_plot_theme+
  NULL

```

##C:N analysis 


```{r CN curves}
CN_base1 <- gam(data = det_loc, CN_ratio ~
                        te(Mass_per_loss, initial_CN, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re") + s(series_index, bs = "re"), 
             method = "REML", family = gaussian(link = "log"), select = TRUE)


CN_base2 <- gam(data = det_loc, CN_ratio ~ 
                        te(Mass_per_loss, initial_CN, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re")+ s(series_index, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 





AIC(CN_base1, CN_base2) #base 2  favored
map(list(CN_base1,CN_base2), appraise) #2 not too bad heteroscedasticity

CN_2a <- gam(data = det_loc, CN_ratio ~  
               ti(Mass_per_loss, m = 2) + ti(initial_CN, m = 2)+
                     ti(Mass_per_loss, initial_CN, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re")+s(series_index, bs = "re"), 
                   method = "REML", family = Gamma(link = "log"),select = TRUE) 

CN_2b <- gam(data = det_loc, CN_ratio ~  
                     ti(Mass_per_loss, m = 2) + ti(initial_CN, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re")+s(series_index, bs = "re"), 
                   method = "REML", family = Gamma(link = "log"),select = TRUE) 

map(list(CN_2a, CN_2b), summary) #interaction term pval = 0.0014
map(list(CN_2a, CN_2b), AIC) #AIC favors interactive model

baseCN_loc.pred<-predict_gam(type = "link", CN_base2, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_CN = c(140,100,70,50,40,25)))%>%
  mutate(initial_CN = fct_relevel(as_factor(initial_CN), c("140","100","70","50","40","25")))


 base_loc_CN.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(CN_ratio)), aes(Mass_per_loss, CN_ratio), alpha = 0.3)+
    geom_smooth(data = baseCN_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_CN))+
    geom_abline(slope = -0.01, intercept = 1)+
   scale_y_continuous(breaks = c(20,50,100,150))+
    ylab("C:N")+
   xlab("Mass Loss (%)")+
   scale_color_brewer(palette = ("Dark2"))+
   guides(color=guide_legend(title="Initial C:N"))+
   theme_bw()+plot_theme+
   NULL

   base_loc_CN.p

```

```{r C:N derivs}
CN_mass_grid <- expand_grid(Mass_per_loss = seq(0,80, by = 0.2), initial_CN = c(25,40,50,70,100,140), series_index = 578)
n_draws <- 10000
CN_mass_grid_exp <- map_dfr(seq_len(n_draws), ~CN_mass_grid)


CN_gam_fitted <- fitted_samples(CN_base2, exclude = "s(series_index,Mass_per_loss", n = n_draws, newdata = CN_mass_grid, seed = 1)%>%
  bind_cols(CN_mass_grid_exp)%>%mutate(initial_CN = as_factor(initial_CN), draw = as_factor(draw), fitted = log(fitted))
#log transformed fitted values because *ratios*


CN_deriv_samples <- CN_gam_fitted%>%arrange(initial_CN)%>%group_by(draw, initial_CN)%>%mutate(fit_dif = (fitted-lag(fitted))/0.2)%>%mutate(Mass_per_loss = as_factor(Mass_per_loss))%>%ungroup()%>%
  group_by(initial_CN, Mass_per_loss)%>%summarize(md_posterior = median(fit_dif), upper_posterior = quantile(fit_dif,0.975,na.rm = TRUE), lower_posterior = quantile(fit_dif,0.025,na.rm = TRUE))

ggplot(data = CN_deriv_samples%>%mutate(Mass_per_loss = as.numeric(as.character(Mass_per_loss)))%>%filter(Mass_per_loss>0))+
         geom_line(aes(x= Mass_per_loss, y = exp(md_posterior)), size = 1)+
  geom_line(aes(x= Mass_per_loss, y = exp(lower_posterior)), linetype = 2)+
  geom_line(aes(x= Mass_per_loss, y = exp(upper_posterior)), linetype = 2)+
  scale_y_continuous(trans="log")+
         facet_wrap(.~initial_CN)+
  #
  geom_hline(yintercept = 1)+
  ylab("First Derivative (C:N/Mass loss)")+
  xlab("Mass Loss (%)")+
  theme_bw()+deriv_plot_theme+
  NULL

```

#C:P base

```{r CP Mass loss}
CP_base1 <- gam(data = det_loc_cnp, CP_ratio ~
                        te(Mass_per_loss, initial_CP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re") + s(series_index, bs = "re"), 
             method = "REML", family = gaussian(link = "log"), select = TRUE)


CP_base2 <- gam(data = det_loc, CP_ratio ~
                  te(Mass_per_loss, initial_CP, m= 2)+
                  s(series_index, Mass_per_loss, bs = "re")+s(series_index, bs = "re"),
                method = "REML", family = Gamma(link = "log"), select = TRUE)

AIC(CP_base1, CP_base2) #delta AIC ~3
map(list(CP_base1, CP_base2), appraise) #essentially the same, selecting gaussian model

CP_1a <- gam(data = det_loc, CP_ratio ~  
               ti(Mass_per_loss, m = 2) + ti(initial_CP, m = 2)+
                     ti(Mass_per_loss, initial_CP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

CP_1b <- gam(data = det_loc, CP_ratio ~  
                     ti(Mass_per_loss, m = 2) + ti(initial_CP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

map(list(CP_1a, CP_1b), summary) #interaction term highly significant - 2.4e-5
map(list(CP_1a, CP_1b), AIC) #favors interaction model


baseCP_loc.pred<-predict_gam(type = "link", CP_base1, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_CP = c(5000,3000,2000,1600,1200,800)))%>%
  mutate(initial_CP = fct_relevel(as_factor(initial_CP), c("5000","3000","2000","1600","1200","800")))



 base_loc_CP.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(CP_ratio)), aes(Mass_per_loss, CP_ratio), alpha = 0.3)+
    geom_smooth(data = baseCP_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_CP))+
   scale_y_continuous(breaks = c(1000,3000,5000, 8000))+
   scale_color_brewer(palette = "Dark2")+
   guides(color=guide_legend(title="Initial C:P"))+
   ylab("C:P")+
   xlab("Mass loss (%)")+
   theme_bw()+plot_theme+
    NULL
 base_loc_CP.p

```

```{r CP derivs}
CP_mass_grid <- expand_grid(Mass_per_loss = seq(0,80, by = 0.2), initial_CP = c(800,1200,1600,2000,3000,5000), series_index = 578)
n_draws <- 10000
CP_mass_grid_exp <- map_dfr(seq_len(n_draws), ~CP_mass_grid)


CP_gam_fitted <- fitted_samples(CP_base1, exclude = "s(series_index,Mass_per_loss", n = n_draws, newdata = CP_mass_grid, seed = 1)%>%
  bind_cols(CP_mass_grid_exp)%>%mutate(initial_CP = as_factor(initial_CP), draw = as_factor(draw), fitted = log(fitted))
#log transformed fitted values because *ratios*


CP_deriv_samples <- CP_gam_fitted%>%arrange(initial_CP)%>%group_by(draw, initial_CP)%>%mutate(fit_dif = (fitted-lag(fitted))/0.2)%>%mutate(Mass_per_loss = as_factor(Mass_per_loss))%>%ungroup()%>%
  group_by(initial_CP, Mass_per_loss)%>%summarize(md_posterior = median(fit_dif), upper_posterior = quantile(fit_dif,0.975,na.rm = TRUE), lower_posterior = quantile(fit_dif,0.025,na.rm = TRUE))

ggplot(data = CP_deriv_samples%>%mutate(Mass_per_loss = as.numeric(as.character(Mass_per_loss)))%>%filter(Mass_per_loss>0))+
         geom_line(aes(x= Mass_per_loss, y = exp(md_posterior)),size = 1)+
  geom_line(aes(x= Mass_per_loss, y = exp(lower_posterior)), linetype = 2)+
  geom_line(aes(x= Mass_per_loss, y = exp(upper_posterior)), linetype = 2)+
         facet_wrap(.~initial_CP)+
  geom_hline(yintercept = 1)+
  scale_y_continuous(trans="log")+
   ylab("First Derivative (C:P/Mass loss)")+
  xlab("Mass Loss (%)")+
  theme_bw()+deriv_plot_theme+
  NULL

```

#N:P base

```{r NP mass loss curves}
NP_base1 <- gam(data = det_loc, NP_ratio ~
                        te(Mass_per_loss, initial_NP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re") + s(series_index, bs = "re"), 
             method = "REML", family = gaussian(link = "log"), select = TRUE)


NP_base2 <- gam(data = det_loc, NP_ratio ~
                  te(Mass_per_loss, initial_NP, m= 2)+
                  s(series_index, Mass_per_loss, bs = "re")+s(series_index, bs = "re"),
                method = "REML", family = Gamma(link = "log"), select = TRUE)

AIC(NP_base1, NP_base2) #2, delAIC=39
map(list(NP_base1, NP_base2), appraise) #resids better on 2

NP_2a <- gam(data = det_loc, NP_ratio ~  
               ti(Mass_per_loss, m = 2) + ti(initial_NP, m = 2)+
                     ti(Mass_per_loss, initial_NP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

NP_2b <- gam(data = det_loc, NP_ratio ~  
                     ti(Mass_per_loss, m = 2) + ti(initial_NP, m = 2)+
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

map(list(NP_2a, NP_2b), summary) #interaction term - 0.0026
map(list(NP_2a, NP_2b), AIC) #delAIC 121 in favor of interactive model


baseNP_loc.pred<-predict_gam(type = "link", NP_base2, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_NP = c(100,70,55,40,25,10)))%>%
  mutate(initial_NP = fct_relevel(as_factor(initial_NP), c("100","70","55","40","25","10")))



 base_loc_NP.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(NP_ratio)), aes(Mass_per_loss, NP_ratio), alpha = 0.3)+
    geom_smooth(data = baseNP_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_NP))+
   scale_y_continuous(breaks = c(10,50,100, 200))+
   scale_color_brewer(palette = "Dark2")+
   guides(color=guide_legend(title="Initial N:P"))+
   ylab("N:P")+
   xlab("Mass loss (%)")+
   theme_bw()+plot_theme+
    NULL
 base_loc_NP.p

```

```{r NP derivs}
NP_mass_grid <- expand_grid(Mass_per_loss = seq(0,80, by = 0.2), initial_NP = c(100,70,55,40,25,10), series_index = 578)
n_draws <- 10000
NP_mass_grid_exp <- map_dfr(seq_len(n_draws), ~NP_mass_grid)


NP_gam_fitted <- fitted_samples(NP_base2, exclude = "s(series_index,Mass_per_loss", n = n_draws, newdata = NP_mass_grid, seed = 1)%>%
  bind_cols(NP_mass_grid_exp)%>%mutate(initial_NP = as_factor(initial_NP), draw = as_factor(draw), fitted = log(fitted))
#log transformed fitted values because *ratios*


NP_deriv_samples <- NP_gam_fitted%>%arrange(initial_NP)%>%group_by(draw, initial_NP)%>%mutate(fit_dif = (fitted-lag(fitted))/0.2)%>%mutate(Mass_per_loss = as_factor(Mass_per_loss))%>%ungroup()%>%
  group_by(initial_NP, Mass_per_loss)%>%summarize(md_posterior = median(fit_dif), upper_posterior = quantile(fit_dif,0.975,na.rm = TRUE), lower_posterior = quantile(fit_dif,0.025,na.rm = TRUE))

ggplot(data = NP_deriv_samples%>%mutate(Mass_per_loss = as.numeric(as.character(Mass_per_loss)))%>%filter(Mass_per_loss>0))+
         geom_line(aes(x= Mass_per_loss, y = exp(md_posterior)),size = 1)+
  geom_line(aes(x= Mass_per_loss, y = exp(lower_posterior)), linetype = 2)+
  geom_line(aes(x= Mass_per_loss, y = exp(upper_posterior)), linetype = 2)+
         facet_wrap(.~initial_NP)+
  geom_hline(yintercept = 1)+
  scale_y_continuous(trans="log")+
   ylab("First Derivative (N:P/Mass loss)")+
  xlab("Mass Loss (%)")+
  theme_bw()+deriv_plot_theme+
  NULL
```