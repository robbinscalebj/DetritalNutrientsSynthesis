---
title: "DetNut Preliminary Analysis"
author: "CJR"
date: "1/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(gratia)
library(mgcv)
library(tidymv)

```

```{r data ingest}


det_raw <- read_csv("C:\\Users\\Caleb_Robbins\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")

```



```{r create new summary variables, include=FALSE}
det <- det_raw%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio),
         initial_Lignin = first(Lignin_per))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*(Mass_per_remaining/100))/((first(N_per)/100)*first(Mass_per_remaining/100)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%


  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given - these NEEDS TO BE CHANGED INTO A TIME-WEIGHTED AVERAGE
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


```

```{r trim data}
det_trim<-det%>%
  filter(Mass_per_remaining<=100)%>%
  filter(Mass_per_remaining >=20)%>%
  filter(initial_N <3)%>%
  filter(!is.na(N_mass_norm))%>%
  filter(N_mass_norm != 0)%>%
  mutate(weights = ifelse(Mass_per_loss == 0, 1e6, 1))%>%
  filter(Detritus_Type == "leaves")%>%
  filter(Detritus_Condition == "senesced")%>%
  filter(Remain_Mass_Category == "afdm"| Remain_Mass_Category == "dm")%>%
  mutate(mesh_cat = fct_drop(mesh_cat, "open"))%>%
  ungroup()



```

#Modeling Framework
We will use our dataset to establish and explore empirical patterns of detrital nutrient content and stoichiometry, and to base future research needs. We can use GAMs to model non-linear patterns (hypothesized based on terrestrial and some aquatic theory). Modeling will highlight patterns but also limits of our dataset, which we can use to define future research objectives.

We explicitly hypothesize that nutrient-mass loss curves are non-linear, strongly predicted by initial nutrient content, and curve inflections are related to initial nutrient content. Exploratory analysis, when possible, should focus on potential alternative factors that predict (or additionally) predict observed patterns beyond initial nutrient content. Other predictors should be tested with and without initial nutrient content - even if not enough data to look at additional predictors (suggests future research), can rule out other models. Additional predictors include Temperature, external N, external P, velocityv


#N modeling
##Lotic Coarse N mass-initial N models
We could use 'by' variables to analyze models along a Lotic_Lentic split (i.e., lotic/lentic would be factor within a single model), but this adds considerable complexity within our modeling framework, particularly during exploratory analysis. Preliminary data visualization/exploration shows these categories are very different in terms of numbers of observations, and I think presenting and discussing qualitative differences between realms will suffice. Note that there are not enough data within the lentic-fine category to fit this GAM structure, but we can visualize it below.



```{r knots test}
#use lotic-coarse data
#requires JOPS

det_loc <- det_trim%>%
  filter(mesh_cat == "coarse", Lotic_Lentic == "Lotic")%>%
  mutate(N_bin = cut_number(initial_N, n = 5))%>%mutate(N_bin = as_factor(N_bin))

N1 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss+1, k = 15, pc = 0), method = "REML", family = Gamma(link = "log"))
draw(N1)

#following pulls the smoothing parameter estimates from the unconstrained model
k <- 13

# Show regular spline fit (and save fitted object)
f.ug <- gam(data = det_lec, N_mass_norm ~ te(Mass_per_loss, TN_approx,  bs = "tp"), method = "REML", family = Gamma(link = "log"))
N <- length(f.ug$fitted.values)-1
f.ug2 <- gam(data = det_lec, N_mass_norm ~ te(Mass_per_loss, initial_N,  bs = "tp"), method = "REML", family = Gamma(link = "log"), weights = c(1e8, 1:N * 0+1))

gam_pred<-predict_gam(f.ug, exclude_terms = "s(series_index)",  values = list(TN_approx = c(10,100,500,1000)))%>% mutate(TN_approx = as_factor(TN_approx))


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = TN_approx))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL




newdata <- data.frame(Mass_per_loss = seq(-1, 80, length.out = 1000))
newdata$y_pred_fit0 <- predict(f.ug, newdata = newdata)
N <- length(f.ug$fitted.values)-1
# explicitly construct smooth term's design matrix
sm <- smoothCon(s(Mass_per_loss,k=k,bs="cr"),data = det_loc,knots=NULL)[[1]]
# find linear constraints sufficient for monotonicity of a cubic regression spline
# it assumes "cr" is the basis and its knots are provided as input
F <- mono.con(sm$xp)

G <- list(
X=sm$X,
C=matrix(0,0,0),  # [0 x 0] matrix (no equality constraints)
sp=f.ug$sp,       # smoothing parameter estimates (taken from unconstrained model)
p=sm$xp,          # array of feasible initial parameter estimates
y=det_loc$N_mass_norm,           
w= c(1e8, 1:N * 0+1)  # weights for data    
)

G$Ain <- F$A        # matrix for the inequality constraints
G$bin <- F$b        # vector for the inequality constraints
G$S <- sm$S         # list of penalty matrices; The first parameter it penalizes is given by off[i]+1
G$off <- 0          # Offset values locating the elements of M$S in the correct location within each penalty coefficient matrix.  (Zero offset implies starting in first location)

p <- pcls(G);       # fit spline (using smoothing parameter estimates from unconstrained fit)

# predict 
newdata$y_pred_fit2 <- Predict.matrix(sm, data.frame(Mass_per_loss = newdata$Mass_per_loss)) %*% p
# plot
plot(N_mass_norm ~ Mass_per_loss, data = det_loc)
lines(y_pred_fit0 ~ Mass_per_loss, data = newdata, col = 2, lwd = 2)
lines(y_pred_fit2 ~ Mass_per_loss, data = newdata, col = 4, lwd = 2)
abline(v = -1)
abline(h = -0.1)

```



```{r b spline thing}
#this forces correct constraints but won't regularize lambda

# Boundary conditions
  bx = c(0,100)
  by = c(1,0)

  # Compute bases for function, first and second derivative 
  bdeg = 3
  nseg = 10
  B0 = bbase(det_loc$Mass_per_loss, bx[1], bx[2], nseg, bdeg)
  nb = ncol(B0)
  Gi = bbase(bx, bx[1], bx[2], nseg, bdeg)


  # Set syste penalty and  with extra penalty
  D   = diff(diag(nb), diff = 2)
  P   = t(D) %*% D
  Bb  = t(B0) %*% B0
  Ci  = t(Gi) %*% Gi
  lam = 0.01 #function isn't regularizing lambda.
  kap = 1e8

  # Solve system strategy 1
  cof_p = solve(Bb + lam * P + kap * Ci) %*% (t(B0) %*% det_loc$N_mass_norm + kap * t(Gi) %*% by)
  
  plot(det_loc$Mass_per_loss, det_loc$N_mass_norm, xlim = bx, pch = 16)
  #lines(det_loc$Mass_per_loss, ys, col = 8, lwd = 2)
  points(bx, by, pch = 15)

  # Strategy 1
  lines(det_loc$Mass_per_loss, B0 %*% cof_p, lwd = 2, col = 2)
  points(bx[1], (Gi %*% cof_p)[1], col = 2, pch = 16)
  points(bx[2], (Gi %*% cof_p)[2], col = 2, pch = 16)

```

```{r Lotic-Coarse}

det_loc <- det_trim%>%
  filter(mesh_cat == "coarse", Lotic_Lentic == "Lotic")%>%
  mutate(N_bin = cut_number(initial_N, n = 5))%>%mutate(N_bin = as_factor(N_bin))
det_loc_Nbins <- levels(det_loc$N_bin)
det_loc<-det_loc%>%
  mutate(N_bin = fct_recode(N_bin, "very low" = det_loc_Nbins[1], low = det_loc_Nbins[2],  med = det_loc_Nbins[3],  high = det_loc_Nbins[4], "very high" = det_loc_Nbins[5]))


N.loc.gam <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(initial_N) + ti(Mass_per_loss, initial_N, k = 16) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.loc.gam1 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.loc.gam2 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15)+ s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

gam_pred<-predict_gam(N.loc.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  gam_pred1<-predict_gam(N.loc.gam1, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred1, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
    gam_pred2<-predict_gam(N.loc.gam2, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred2, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  summary(N.loc.gam)
  appraise(N.loc.gam)
  k.check(N.loc.gam)
  draw(N.loc.gam1)
   summary(N.loc.gam1)
  appraise(N.loc.gam1)
  k.check(N.loc.gam1)
  draw(N.loc.gam2)
     summary(N.loc.gam2)
  appraise(N.loc.gam2)
  k.check(N.loc.gam2)

```
 No evidence for initial N being a strong predictor of these Lotic-Coarse curves - N mass a function of mass loss alone, but not necessarily linear.
 
## N Mass exploratory modeling
 So what might explain some of the variation during mass loss? We can keep these models relatively simple for two primary reasons: 1) Interactions in GAMs may become intractable and difficult to interpret, and 2) The more covariates included in a single model, the fewer observations from which to estimate effects. We simply have to be careful about how we interpret the significance here - it is exploratory modeling into 'global'-level trends.
 
```{r Lotic Coarse exploratory models}

N.loc.temp <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.tn <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.tp <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TP_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.vel <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.ph <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(pH) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.lig <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Total_Phenolics_per) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscat <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 25, bs = "fs") + Remain_Mass_Category + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.erg <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Ergosterol_ug.g) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscattemp <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscatvel <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))



summary(N.loc.temp)
summary(N.loc.tn)
summary(N.loc.tp)
summary(N.loc.vel)
summary(N.loc.ph)
summary(N.loc.masscat)
summary(N.loc.erg)
summary(N.loc.masscattemp)


```
 No evidence for initial N being a strong predictor of these Lotic-Coarse curves - N mass a function of mass loss alone, but not necessarily linear.
 
## N Mass lotic exploratory modeling
 So what might explain some of the variation during mass loss? We can keep these models relatively simple for two primary reasons: 1) Interactions in GAMs may become intractable and difficult to interpret, and 2) The more covariates included in a single model, the fewer observations from which to estimate effects. We simply have to be careful about how we interpret the significance here - it is exploratory modeling into 'global'-level trends.
 
```{r Lotic Coarse exploratory models}

N.loc.temp <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.ext <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx) +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.tn <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.tp <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TP_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.vel <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.ph <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(pH) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.lig <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Total_Phenolics_per) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscat <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 25, bs = "fs") + Remain_Mass_Category + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.erg <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Ergosterol_ug.g) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscattemp <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscatvel <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))



summary(N.loc.temp)
summary(N.loc.tn)
summary(N.loc.tp)
summary(N.loc.vel)
summary(N.loc.ph)
summary(N.loc.masscat)
summary(N.loc.erg)
summary(N.loc.masscattemp)



```

```{r}

N.ext <- gam(data = det_loc, N_mass_norm ~ s(initial_N) + s(series_index, bs = "re") + s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="log"))
summary(N.ext)

 gam_pred.ext<-predict_gam(N.ext, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0), Velocity_m.s = c(0.05,0.1,0.2,0.4)))%>% mutate(initial_N = as_factor(initial_N), velocity_m.s = as_factor(Velocity_m.s))


  ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred.ext, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    facet_grid(.~velocity_m.s)+
    NULL

```
 
 
 
 ##Coarse Lentic Nmass~initialN



 
 
 ##Coarse Lentic Nmass~initialN


```{r Coarse Lentic only}

det_lec <- det_trim%>%
  filter(mesh_cat == "coarse", Lotic_Lentic == "Lentic")
  det_lec_Nbins <- levels(det_loc$N_bin)
#det_lec<-det_lec%>%
#  mutate(N_bin = fct_recode(N_bin, "very low" = det_lec_Nbins[1], low = det_lec_Nbins[2],  med = det_lec_Nbins[3],  high = #det_lec_Nbins[4], "very high" = det_lec_Nbins[5]))

N.lec.gam <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(initial_N) + ti(Mass_per_loss, initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam1 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam2 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss)+ s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam3 <- gam(data = det_lec, N_mass_norm ~ ti(Mass_per_loss, initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam4 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lec.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred1<-predict_gam(N.lec.gam1, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred1, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  gam_pred2<-predict_gam(N.lec.gam2, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred2, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred3<-predict_gam(N.lec.gam3, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred3, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred4<-predict_gam(N.lec.gam4, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred4, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  summary(N.lec.gam)
  appraise(N.lec.gam)
  k.check(N.lec.gam)
  draw(N.lec.gam1)
   summary(N.lec.gam1)
  appraise(N.lec.gam1)
  k.check(N.lec.gam1)
  draw(N.lec.gam2)
     summary(N.lec.gam2)
  appraise(N.lec.gam2)
  k.check(N.lec.gam2)
     summary(N.lec.gam3)
  appraise(N.lec.gam3)
  k.check(N.lec.gam3)
    summary(N.lec.gam4)
  appraise(N.lec.gam4)
  k.check(N.lec.gam4)
  
  
  AIC(N.lec.gam,N.lec.gam1,N.lec.gam2,N.lec.gam3, N.lec.gam4)
```
The MassxInitial N tensor interaction model is not horribly predictive model. However, it is the most parsimonious fit (lowest AIC) of all the base models. 

## N Mass lentic exploratory modeling

```{r Lentic Coarse exploratory models}

N.lec.temp <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tn <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tp <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TP_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tpn <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TP_approx) +s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.vel <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.ph <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(pH) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.lig <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Total_Phenolics_per) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.masscat <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))


#N.lec.erg <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Ergosterol_ug.g) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.masscattemp <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category +s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.masscatvel <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))



summary(N.lec.temp)
summary(N.lec.tn)
summary(N.lec.tp)
#summary(N.lec.vel)
#summary(N.lec.ph)
summary(N.lec.masscat)
#summary(N.lec.erg)
summary(N.lec.masscattemp)


AIC(N.lec.temp, N.lec.tn,N.lec.tp,N.lec.masscat,N.lec.masscattemp)
```
 
 
##N mass lotic-fine modeling 
=======

```{r Lotic - Fine only}

det_lof <- det_trim%>%
  filter(mesh_cat == "fine", Lotic_Lentic == "Lotic")%>%mutate(N_bin = cut_number(initial_N, n = 5))%>%mutate(N_bin = as_factor(N_bin))
det_lof_Nbins <- levels(det_loc$N_bin)
det_lof<-det_lof%>%
  mutate(N_bin = fct_recode(N_bin, "very low" = det_lof_Nbins[1], low = det_lof_Nbins[2],  med = det_lof_Nbins[3],  high = det_lof_Nbins[4], "very high" = det_lof_Nbins[5]))

N.lof.gam <- gam(data = det_lof, N_mass_norm ~ te(Mass_per_loss, initial_N,  bs = "cr") + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lof.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.45,0.7,1.0,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  
    ggplot()+
  geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
  geom_point(data = det_lof, aes(Mass_per_loss, N_mass_norm), alpha = 0.5)+
    scale_x_continuous(limits = c(0,95))+
    scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  
   summary(N.lof.gam)
  appraise(N.lof.gam)
  k.check(N.lof.gam)
```

##N mass lentic-fine modeling 
The Lentic-fine model won't fit - not enough data.
```{r Lentic - Fine}

det_lef <- det_trim%>%
  filter(mesh_cat == "fine", Lotic_Lentic == "Lentic")

N.lef.gam <- gam(data = det_lef, N_mass_norm ~ te(Mass_per_loss, initial_N,  bs = "cr") + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lef.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
  geom_point(data = det_lef, aes(Mass_per_loss, N_mass_norm), alpha = 0.05)+
    scale_x_continuous(limits = c(0,95))+
    #facet_grid(.~Lotic_Lentic)+
    scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
```

##Basic N Mass loss~time models
```{r coarse}


N.lct.gam <- gam(data = det_loc, N_mass_norm ~ s(Meas_Day,Lotic_Lentic, bs = "fs")+s(initial_N, Lotic_Lentic, bs = "fs")+ti(Meas_Day, initial_N,  bs = "cr", by = Lotic_Lentic) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lct.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.7,1.0,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  
    ggplot()+
      geom_point(data = det_loc, aes(Meas_Day, N_mass_norm), alpha = 0.5)+
      geom_point(data = gam_pred, aes(x = Meas_Day, y = exp(fit), color = initial_N))+
      facet_grid(.~Lotic_Lentic)+
    #scale_x_continuous(limits = c(0,95))+
      scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
      geom_abline(slope = -0.01, intercept = 1)+
      NULL
    
  
  draw(N.lct.gam)
  summary(N.lct.gam)
  appraise(N.lct.gam)
  k.check(N.lct.gam)
  
```





#P modeling
##Basic P mass loss models
##Basic P mass loss~time models
##Exploratory P mass modeling


#Stoichiometry - could following be separate paper?
This paper could focus on patterns of stoichiometric convergence a la some of Manning papers
Look at results of everything then decide
#CN modeling
##CN mass loss by initial N
##CN exploratory

#CP modeling
##CP mass loss by initial P
##CP exploratory

#NP modeling
##NP exploratory




