---
title: "DetNut Preliminary Analysis"
author: "CJR"
date: "1/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(gratia)
library(mgcv)
library(tidymv)

```

```{r data ingest}


det_raw <- read_csv("C:\\Users\\robbi\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")

```



```{r create new summary variables, include=FALSE}
det <- det_raw%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio),
         initial_Lignin = first(Lignin_per))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass = ((C_per/100)*Mass_per_remaining),
         N_mass = ((N_per/100)*Mass_per_remaining),
         P_mass = ((P_per/100)*Mass_per_remaining),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*(Mass_per_remaining/100))/((first(N_per)/100)*first(Mass_per_remaining/100)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%


  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given - these NEEDS TO BE CHANGED INTO A TIME-WEIGHTED AVERAGE
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


```

```{r trim data}
det_trim<-det%>%
  filter(Mass_per_remaining<=100)%>%
  filter(Mass_per_remaining >=20)%>%
  filter(initial_N <3)%>%
  filter(!is.na(N_mass_norm))%>%
  filter(N_mass_norm != 0)%>%
  mutate(weights = ifelse(Mass_per_loss == 0, 1e6, 1))%>%
  filter(Detritus_Type == "leaves")%>%
  filter(Detritus_Condition == "senesced")%>%
  filter(Remain_Mass_Category == "dm"|Remain_Mass_Category == "afdm")%>%
  filter(mesh_cat != "open")%>%
  mutate(Remain_Mass_Category = fct_drop(Remain_Mass_Category, only = c("dm_postleach", "afdm_postleach", "organic_carbon")))%>%
  mutate(mesh_cat = fct_drop(mesh_cat, "open"))%>%
  ungroup()

levels(det_trim$Remain_Mass_Category)
levels(det_trim$mesh_cat)


```

#Modeling Framework
We will use our dataset to establish and explore empirical patterns of detrital nutrient content and stoichiometry, and to base future research needs. We can use GAMs to model non-linear patterns (hypothesized based on terrestrial and some aquatic theory). Modeling will highlight patterns but also limits of our dataset, which we can use to define future research objectives.


We explicitly hypothesize that nutrient-mass loss curves are non-linear, strongly predicted by initial nutrient content, and curve inflections are related to initial nutrient content. Exploratory analysis, when possible, should focus on potential alternative factors that predict (or additionally predict) observed patterns beyond initial nutrient content. Other predictors should be tested with and without initial nutrient content - even if not enough data to look at additional predictors (suggests future research), can rule out other models. Additional predictors include Temperature, external N, external P, velocity...

Specifically, the GAMs will have some mixed effects, to model 'subject-specific' (i.e., each time series) trends. This means a random slope - we need not model a  random intercept because the N_mass_loss data all start at a known point - each series starting point is normalized to 1. If we model unnormalized N mass as a response, we may want to include  random intercept. 


#N modeling
##Lotic Coarse N mass-initial N models
We could use 'by' variables to analyze models along a Lotic_Lentic split (i.e., lotic/lentic would be factor within a single model), but this adds considerable complexity within our modeling framework, particularly during exploratory analysis. Preliminary data visualization/exploration shows these categories are very different in terms of numbers of observations, and I think presenting and discussing qualitative differences between realms will suffice. Note that there are not enough data within the lentic-fine category to fit this GAM structure, but we can visualize it below.



```{r Lotic-Coarse global N loss model}

det_loc <- det_trim%>%
  filter(mesh_cat == "coarse", Lotic_Lentic == "Lotic")%>%
  mutate(N_bin = cut_number(initial_N, n = 5))%>%mutate(N_bin = as_factor(N_bin))
  #filter(Mass_per_loss>0) #was worried about all the points at 0,1 inflating the R^2 (is that a thing?) but the effect is very small in removing vs retaining


#base model - global change in N mass curves - includes random slope, but not random intercept - uniform intercept desirable
#after tinkering, Gamma distro with inverse link function yields best residuals
N.loc.rs <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link = "inverse"))
summary(N.loc.rs)
appraise(N.loc.rs)
draw(N.loc.rs)
k.check(N.loc.rs)

gam_pred<-predict_gam(N.loc.rs, exclude_terms = "s(series_index,Mass_per_loss)")
 N.loc.rs.p<- ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = gam_pred, aes(x = Mass_per_loss, y = 1/fit))+
    geom_abline(slope = -0.01, intercept = 1)+
    geom_ribbon(data = gam_pred, aes(x = Mass_per_loss, ymin = 1/(fit -2*se.fit), ymax = 1/(fit +2*se.fit)), alpha = 0.3)+
    NULL
 N.loc.rs.p
  
```
Overall this model isn't too bad, and explains a lot of variation, ~90%. It also suggests that N loss is non-linear, though it doesn't seem super wiggly when plotted.

We can check if mass category is potentially causing interpretation problems.The main way to handle this is as a factor-smooth interaction between mass loss and mass category (can't use random effects because only two levels of mass category - need ~5 to be reliable)
```{r Lotic-Coarse Check Mass category problems}

N.loc.rs2 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(series_index, Mass_per_loss, bs = "re") + s(Remain_Mass_Category, Mass_per_loss, bs = "fs"), method = "REML", family = Gamma(link = "inverse"))
summary(N.loc.rs2)
appraise(N.loc.rs2)
k.check(N.loc.rs2)
#can't draw() with factor like this


gam_pred<-predict_gam(N.loc.rs2, exclude_terms = "s(series_index,Mass_per_loss)")
 N.loc.rs2.p<- ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = gam_pred, aes(x = Mass_per_loss, y = 1/fit))+
    geom_abline(slope = -0.01, intercept = 1)+
    facet_grid(.~Remain_Mass_Category)+
    geom_ribbon(data = gam_pred, aes(x = Mass_per_loss, ymin = 1/(fit -2*se.fit), ymax = 1/(fit +2*se.fit)), alpha = 0.3)+
    NULL
N.loc.rs2.p
  
AIC(N.loc.rs,N.loc.rs2)
```
There's good reason to suspect that Mass category affects these curves - factor smooth term is significant, and a substantial reduction in AIC on model comparison. Looking at the plotted curves, DM curves tend to lose proportionally less N through time. My guess is that's a function of mass loss being underestimated at those time points in comparison to AFDM - this may be a signal from inorganic matter becoming an increasingly larger proportion of mass throughout decomposition (i.e., the x axis doesn't mean the same thing on tehse two plots). The good news is now we can retain this in our models to 1. control for it or 2. see if that signal can actually be explained by something else. 

 
## N Mass lotic exploratory modeling
 So what might explain some of the variation during mass loss? We can keep these models relatively simple for two primary reasons: 1) Interactions in GAMs may become intractable and difficult to interpret, and 2) The more covariates included in a single model, the fewer observations from which to estimate effects. We simply have to be careful about how we interpret the significance here - it is exploratory modeling into 'global'-level trends. Additionally, we can also tell lots of non-linearity gets picked up by mass loss as single predictor, so we don't consider additional tensor-smooth interactions in our exploratory modeling. We want to keep our random effects and 
 
 Exogenous, endogenous, and methodological exploratory models informed combination models 
 
```{r Lotic Coarse exploratory models - Ext TN}

#ext vars = TP, TN, Velocity, Temp

N.ext1 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) +s(Velocity_m.s) +s(TN_approx_avg) +s(Temperature_C)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext2 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s)  + ti(Mass_per_loss, Temperature_C)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext3 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) +  ti(Mass_per_loss, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext4 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Mass_per_loss, Velocity_m.s)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext5 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Velocity_m.s, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext6 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Temperature_C, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext7 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Temperature_C, Velocity_m.s)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext8 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Mass_per_loss, Velocity_m.s, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

AIC(N.ext1,N.ext2,N.ext3,N.ext4,N.ext5,N.ext6,N.ext7)

#summary(N.ext1);
summary(N.ext2);summary(N.ext3);summary(N.ext4);#summary(N.ext5);summary(N.ext6);summary(N.ext7);
#appraise(N.ext3)

#gam_pred<-predict_gam(N.ext4, exclude_terms = c("s(series_index,Mass_per_loss)", "s(Temperature_C)", "s(TN_approx_avg)"), values = list(Velocity_m.s = 0.3,0.1,0.4))
 N.ext4.p<- ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = gam_pred, aes(x = Mass_per_loss, y = 1/fit))+
    geom_abline(slope = -0.01, intercept = 1)+
    facet_grid(.~Remain_Mass_Category)+
    geom_ribbon(data = gam_pred, aes(x = Mass_per_loss, ymin = 1/(fit -2*se.fit), ymax = 1/(fit +2*se.fit)), alpha = 0.3)+
    NULL
N.loc.rs2.p
```
Models 2,3,4 come out with lowest AIC values, suggesting some level of interaction with Mass loss of TN, Velocity, or Temp could be important in shaping the curves of 

```{r Lotic Coarse exploratory models - Ext TP}
N.ext1 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) +s(Velocity_m.s) +s(TN_approx_avg) +s(Temperature_C)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext2 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s)  + ti(Mass_per_loss, Temperature_C)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext3 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) +  ti(Mass_per_loss, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext4 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Mass_per_loss, Velocity_m.s)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext5 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Velocity, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext6 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Temperature_C, TN_approx_avg)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

N.ext7 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(TN_approx_avg) +s(Velocity_m.s) + ti(Temperature_C, Velocity_m.s)+ s(Remain_Mass_Category, Mass_per_loss, bs = "fs")+s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="inverse"))

```

```{r Lotic Coarse exploratory models - Endo lig}

```

```{r Lotic Coarse exploratory models - Endo hemi}

```

```{r Lotic Coarse exploratory models - Endo phenol}

```


```{r Lotic Coarse exploratory models - Exo-Endo combined}

```
#N.extn variations = TP, velocity should also receive a separate model to investigate, e.g., its moderation (interaction) on Mass_per_loss

N.end1 <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss) + s(initial_N) + s(initial_Lignin) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.endn alternatives gets phenolics, hemicell? initial_P? NP?

N.met1 <- ...needs to be Masscat, basically. continous mesh size?

N.com1 <-

N.loc.tn <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.tp <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(TP_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.vel <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.ph <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(pH) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.lig <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Total_Phenolics_per) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscat <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 25, bs = "fs") + Remain_Mass_Category + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.erg <- gam(data = det_loc, N_mass_norm ~ s(Mass_per_loss, k = 15) + s(Ergosterol_ug.g) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscattemp <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.loc.masscatvel <- gam(data = det_loc[det_loc$Remain_Mass_Category == "afdm"|det_loc$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, k = 15, bs = "fs") + Remain_Mass_Category +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))



summary(N.loc.temp)
summary(N.loc.tn)
summary(N.loc.tp)
summary(N.loc.vel)
summary(N.loc.ph)
summary(N.loc.masscat)
summary(N.loc.erg)
summary(N.loc.masscattemp)



```

```{r}

N.ext <- gam(data = det_loc, N_mass_norm ~ s(initial_N) + s(series_index, bs = "re") + s(series_index, Mass_per_loss, bs = "re"), method = "REML", family = Gamma(link="log"))
summary(N.ext)

 gam_pred.ext<-predict_gam(N.ext, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0), Velocity_m.s = c(0.05,0.1,0.2,0.4)))%>% mutate(initial_N = as_factor(initial_N), velocity_m.s = as_factor(Velocity_m.s))


  ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred.ext, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    facet_grid(.~velocity_m.s)+
    NULL

```
 
 
 

 ##Coarse Lentic Nmass~initialN


```{r Coarse Lentic only}

det_lec <- det_trim%>%
  filter(mesh_cat == "coarse", Lotic_Lentic == "Lentic")
  det_lec_Nbins <- levels(det_loc$N_bin)
#det_lec<-det_lec%>%
#  mutate(N_bin = fct_recode(N_bin, "very low" = det_lec_Nbins[1], low = det_lec_Nbins[2],  med = det_lec_Nbins[3],  high = #det_lec_Nbins[4], "very high" = det_lec_Nbins[5]))

N.lec.gam <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(initial_N) + ti(Mass_per_loss, initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam1 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam2 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss)+ s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam3 <- gam(data = det_lec, N_mass_norm ~ ti(Mass_per_loss, initial_N) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

N.lec.gam4 <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lec.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred1<-predict_gam(N.lec.gam1, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred1, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  gam_pred2<-predict_gam(N.lec.gam2, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred2, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred3<-predict_gam(N.lec.gam3, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred3, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
gam_pred4<-predict_gam(N.lec.gam4, exclude_terms = "s(series_index)")


  ggplot()+
  geom_point(data = det_lec, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_point(data = gam_pred4, aes(x = Mass_per_loss, y = exp(fit)))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  summary(N.lec.gam)
  appraise(N.lec.gam)
  k.check(N.lec.gam)
  draw(N.lec.gam1)
   summary(N.lec.gam1)
  appraise(N.lec.gam1)
  k.check(N.lec.gam1)
  draw(N.lec.gam2)
     summary(N.lec.gam2)
  appraise(N.lec.gam2)
  k.check(N.lec.gam2)
     summary(N.lec.gam3)
  appraise(N.lec.gam3)
  k.check(N.lec.gam3)
    summary(N.lec.gam4)
  appraise(N.lec.gam4)
  k.check(N.lec.gam4)
  
  
  AIC(N.lec.gam,N.lec.gam1,N.lec.gam2,N.lec.gam3, N.lec.gam4)
```
The MassxInitial N tensor interaction model is not horribly predictive model. However, it is the most parsimonious fit (lowest AIC) of all the base models. But the fit is shit - wonder if that's because the equal initial values on 1 is correlated highly to initial_N or something like that)! Any exploratory models fit better?

## N Mass lentic exploratory modeling
This will be limited compared to lotic analysis thanks to severely decreased sample size.

```{r Lentic Coarse exploratory models}

N.lec.temp <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tn <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tp <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TP_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.tpn <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(TP_approx) +s(TN_approx) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.vel <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.ph <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(pH) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.lig <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Total_Phenolics_per) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.masscat <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))


#N.lec.erg <- gam(data = det_lec, N_mass_norm ~ s(Mass_per_loss) + s(Ergosterol_ug.g) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

N.lec.masscattemp <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category +s(Temperature_C) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))

#N.lec.masscatvel <- gam(data = det_lec[det_lec$Remain_Mass_Category == "afdm"|det_lec$Remain_Mass_Category == "dm",], N_mass_norm ~ s(Mass_per_loss, Remain_Mass_Category, bs = "fs") + Remain_Mass_Category +s(Velocity_m.s) + s(series_index, bs = "re"), method = "REML", family = Gamma(link="log"))



summary(N.lec.temp)
summary(N.lec.tn)
summary(N.lec.tp)
#summary(N.lec.vel)
#summary(N.lec.ph)
summary(N.lec.masscat)
#summary(N.lec.erg)
summary(N.lec.masscattemp)


AIC(N.lec.temp, N.lec.tn,N.lec.tp,N.lec.masscat,N.lec.masscattemp)
```
 
 
##N mass lotic-fine modeling 
=======

```{r Lotic - Fine only}

det_lof <- det_trim%>%
  filter(mesh_cat == "fine", Lotic_Lentic == "Lotic")%>%mutate(N_bin = cut_number(initial_N, n = 5))%>%mutate(N_bin = as_factor(N_bin))
det_lof_Nbins <- levels(det_loc$N_bin)
det_lof<-det_lof%>%
  mutate(N_bin = fct_recode(N_bin, "very low" = det_lof_Nbins[1], low = det_lof_Nbins[2],  med = det_lof_Nbins[3],  high = det_lof_Nbins[4], "very high" = det_lof_Nbins[5]))

N.lof.gam <- gam(data = det_lof, N_mass_norm ~ te(Mass_per_loss, initial_N,  bs = "cr") + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lof.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.45,0.7,1.0,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  
    ggplot()+
  geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
  geom_point(data = det_lof, aes(Mass_per_loss, N_mass_norm), alpha = 0.5)+
    scale_x_continuous(limits = c(0,95))+
    scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
  
   summary(N.lof.gam)
  appraise(N.lof.gam)
  k.check(N.lof.gam)
```

##N mass lentic-fine modeling 
The Lentic-fine model won't fit - not enough data.
```{r Lentic - Fine}

det_lef <- det_trim%>%
  filter(mesh_cat == "fine", Lotic_Lentic == "Lentic")

N.lef.gam <- gam(data = det_lef, N_mass_norm ~ te(Mass_per_loss, initial_N,  bs = "cr") + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lef.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.4,0.5, 0.6,0.8, 1,1.5,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
  geom_point(data = det_lef, aes(Mass_per_loss, N_mass_norm), alpha = 0.05)+
    scale_x_continuous(limits = c(0,95))+
    #facet_grid(.~Lotic_Lentic)+
    scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
  
```

##Basic N Mass loss~time models
```{r coarse}


N.lct.gam <- gam(data = det_loc, N_mass_norm ~ s(Meas_Day,Lotic_Lentic, bs = "fs")+s(initial_N, Lotic_Lentic, bs = "fs")+ti(Meas_Day, initial_N,  bs = "cr", by = Lotic_Lentic) + s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))


gam_pred<-predict_gam(N.lct.gam, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.3,0.7,1.0,2.0,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  
    ggplot()+
      geom_point(data = det_loc, aes(Meas_Day, N_mass_norm), alpha = 0.5)+
      geom_point(data = gam_pred, aes(x = Meas_Day, y = exp(fit), color = initial_N))+
      facet_grid(.~Lotic_Lentic)+
    #scale_x_continuous(limits = c(0,95))+
      scale_y_continuous(limits = c(0,3), breaks = c(0,0.5,1,2))+
      geom_abline(slope = -0.01, intercept = 1)+
      NULL
    
  
  draw(N.lct.gam)
  summary(N.lct.gam)
  appraise(N.lct.gam)
  k.check(N.lct.gam)
  
```





#P modeling
##Basic P mass loss models
##Basic P mass loss~time models
##Exploratory P mass modeling


#Stoichiometry - could following be separate paper?
This paper could focus on patterns of stoichiometric convergence a la some of Manning papers
Look at results of everything then decide
#CN modeling
##CN mass loss by initial N
##CN exploratory

#CP modeling
##CP mass loss by initial P
##CP exploratory

#NP modeling
##NP exploratory




