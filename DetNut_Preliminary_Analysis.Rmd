---
title: "DetNut Preliminary Analysis"
author: "CJR"
date: "1/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(assertr)
library(janitor)
library(gratia)
library(mgcv)
library(tidymv)

```

```{r data ingest}


det <- read_csv("C:\\Users\\Caleb_Robbins\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")

```



```{r create new summary variables, include=FALSE}
det2 <- det%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio),
         initial_Lignin = first(Lignin_per))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*Mass_per_remaining)/(first(N_per/100)*first(Mass_per_remaining)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%
  #fill in any places where ratios could have been calculated, but weren't

  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given - these NEEDS TO BE CHANGED INTO A TIME-WEIGHTED AVERAGE
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


#Time-integrated conditions - already calculated degree days, but could do to approximate a cumulative N load, P load, etc.

```

```{r trim data}
det3<-det2%>%
  filter(Mass_per_remaining<=100)%>%
 # filter(!between(Meas_Day, 0,7))%>%
  filter(Mass_per_remaining >=20)%>%
  filter(initial_N <3)%>%
  filter(!is.na(N_mass_norm))%>%
  filter(N_mass_norm != 0)%>%
  mutate(weights = ifelse(Mass_per_loss == 0, 1e6, 1))%>%
  filter(Detritus_Type == "leaves", System == "stream")%>%
filter(Remain_Mass_Category == "afdm"| Remain_Mass_Category == "dm")
 # filter(mesh_cat == "coarse")%>%
 # filter(Detritus_Type == "leaves")
  

```


```{r}

det4<-det3%>%
  filter(Detritus_Type == "leaves", System == "stream")%>%
  mutate(Decomp_Period = case_when(Meas_Day >=24 & Meas_Day <60 ~ "Mid-term",
                                   Meas_Day <24 ~ "Short-term",
                                   Meas_Day >=60 ~ "Late-term"),
         k_sp = -(log(Mass_per_remaining/100))/Meas_Day)%>%
  #select(Meas_Day, Mass_per_remaining, Decomp_Period, k_sp)%>%
  filter(Meas_Day >0)


ggplot(data = det3, aes (x = Mass_per_loss, y = N_mass_norm))+
  geom_point()+
  geom_smooth(method = "gam")+
  #scale_y_continuous (limits = c(0,3))+
  #facet_wrap(.~Decomp_Period, scales = "free")+
NULL

```

#GAM

Central hypothesis here is: Detrital nutrient mass is non-linearly driven by decomposition stage and initial detrital nutrient content
Alt hypotheses: Linear relationship and/or no significant variation explained by initial detrital nutrient content.

basic viz could plot groups of initial N as loess curves along Mass loss






```{r GAM initial N}

#could specify knots to be equally distributed by amount of data
#gam(data = det3, N_mass_norm ~ te(Mass_per_loss, initial_N, by = Lotic_Lentic)

#N.gam <- gam(data = det3, N_mass_norm ~ te(Mass_per_loss, initial_N) +s(series_index, bs = "re"), method = "REML") #this is really overestimating curves at high end in particular.

N.gam.gamma1 <- gam(data = det3, N_mass_norm ~ te(Mass_per_loss, initial_N, bs = "cr", k = c(15, 10)) +  s(series_index, bs = "re"), method = "REML", family = Gamma(link = "log"))

#knots = list(Mass_per_loss = c(0,2,4,6,8,11,13,17,20,40,60,80))

#N.gam.gamma1k <- gam(data = det3, N_mass_norm ~ te(Mass_per_loss, initial_N, k = c(9, 5), by = Lotic_Lentic) +s(series_index, bs = "re"), knots = list(Mass_per_loss = c(0,3,7,12,17,20,40,60,80)), method = "REML", family = Gamma(link = "log"))

#N.gam.gamma2 <- gam(data = det3, N_mass_norm ~ te(Mass_per_loss, initial_N) +s(series_index, bs = "re"), method = "REML", family = Gamma(link = "inverse"))

#summary(N.gam)
#draw(N.gam)
#appraise(N.gam)

summary(N.gam.gamma1)
draw(N.gam.gamma1)
appraise(N.gam.gamma1)

#summary(N.gam.gamma2)
#draw(N.gam.gamma2)
#appraise(N.gam.gamma2)

#summary(N.gam.gamma1k)
#draw(N.gam.gamma1k)
#appraise(N.gam.gamma1k)

```


```{r plot predictions }
gam_pred<-predict_gam(N.gam.gamma1, exclude_terms = "s(series_index)",  values = list(initial_N = c(0.4,0.5, 0.6,0.8, 1,2,2.5)))%>% mutate(initial_N = as_factor(initial_N))


  ggplot()+
  geom_point(data = gam_pred, aes(x = Mass_per_loss, y = exp(fit), color = initial_N))+
  geom_point(data = det3[!is.na(det3$Lotic_Lentic),], aes(Mass_per_loss, N_mass_norm), alpha = 0.05)+
    scale_x_continuous(limits = c(0,95))+
    facet_grid(.~Lotic_Lentic)+
    scale_y_continuous(limits = c(0,4), breaks = c(0,0.5,1,2))+
    #geom_abline(slope = -0.01, intercept = 1)+
    NULL


```
Tendency is for %N to actually increase in the first few days of incubation - more mass of 'stuff' leaches than N. Early hump is likely an 'retention' of N relative to overall mass lost, therefore more N than initially
```{r calc derivatives}

m2.d <- fderiv(N.gam.gamma1)

```
