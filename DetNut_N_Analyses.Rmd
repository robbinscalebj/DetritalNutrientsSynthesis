---
title: "DetNut_NP_Analysis"
author: "CJR"
date: "2/5/2022"
output: html_document
---

##Setup and Data Trim
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(gratia)
library(mgcv)
library(tidymv)

```

```{r data ingest}


det_raw <- read_csv("C:\\Users\\robbi\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")

```



```{r create new summary variables, include=FALSE}
det <- det_raw%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio),
         initial_Lignin = first(Lignin_per))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass = ((C_per/100)*Mass_per_remaining),
         N_mass = ((N_per/100)*Mass_per_remaining),
         P_mass = ((P_per/100)*Mass_per_remaining),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*(Mass_per_remaining/100))/((first(N_per)/100)*first(Mass_per_remaining/100)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%


  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


```

```{r trim data}
det_trim<-det%>%
  filter(Mass_per_remaining<=100)%>%
  filter(Mass_per_remaining >=20)%>%
  #filter(N_mass_norm != 0)%>%
  filter(Detritus_Type == "leaves")%>%
  filter(Detritus_Condition == "senesced")%>%
  filter(Remain_Mass_Category == "dm"|Remain_Mass_Category == "afdm")%>%
  filter(mesh_cat != "open")%>%
  mutate(Remain_Mass_Category = fct_drop(Remain_Mass_Category, only = c("dm_postleach", "afdm_postleach", "organic_carbon")))%>%
  mutate(mesh_cat = fct_drop(mesh_cat, "open"))%>%
  ungroup()

levels(det_trim$Remain_Mass_Category)
levels(det_trim$mesh_cat)
levels(det_trim$Lotic_Lentic)

```

We can use generalized additive models (GAMs) to explore global trends of detrital nutrients. This allows us to examine the trends and interacting covariates, as terms with non-linear effects throughout litter breakdown. 

Lotic and Lentic categories have vastly different quantities of measurements. Further, it is another step in complication to include an additional model term to quantify tensor-product interactions in mesh size and habitat (stepping up to very high level interactions on top of base fixed effects). To keep it simple(r), we will qualitatively assess differences in model predictions between habitat/mesh size. 



```{r create separate lotic-lentic fine-coarse datasets}

det_loc <- det_trim%>%filter(mesh_cat == "coarse", Lotic_Lentic == "Lotic")
det_lec <- det_trim%>%filter(mesh_cat == "coarse", Lotic_Lentic == "Lentic")
det_lof <- det_trim%>%filter(mesh_cat == "fine", Lotic_Lentic == "Lotic")
det_lef <- det_trim%>%filter(mesh_cat == "fine", Lotic_Lentic == "Lentic")

```



The overall analysis plan is this: For each response variable (Normalized N or P mass, N or P %, and CNP), we want to test how curves change during litter breakdown (mass loss), and explore how covariates might change those global relationships. 

We always want to control for group-specific variation, which we do with random slope/intercept terms. The random intercept doesn't make sense for response variables where the intercepts are all defined as 1 (and so each series starts at 1) or where one of the covariates defines a time series' intercept (e.g., response N% and covariate initial N %). 

Inference during exploratory modeling will be based on a two step process - 1) Models with the same fixed effects and random effects  structure will be compared across different distributional assumptions via AIC and model residual checks. 2) We will examine the p-values on the term of interest (basically an interaction between Mass loss and the potentially important covariate). Unfortunately, we can't always use AIC to compare models with covariates to a base model without the covariate, because covariate observations are not always complete - i.e., the sample sizes of the two models can be different because not all covariates coincide with all observations. AIC doesn't work in these situations. Thus, we are stuck with imprecise GAM pvalues to test the significance of an included covariate fixed term. Further, the R2 values on mixed GAMs are almost meaningless for our intentions. But we can qualitatively assess how much a covariate term changes the prediction by visualizing the predictions.


Note, there are very few afdm measurements from lentic sites and that creates a substantial problem for analyzing lentic/lotic together. There's simply not enough data even to fit a base model well (at least accounting for afdm/dm differences which can be done differently in a simpler analysis), so lentic data need to be analyzed with a simpler, less robust modeling approach, which is fine. But the focus can be on the lotic data at least for now.




#N mass models
##Base initial N models


So, we'll create a base model with just mass loss as a predictor (plus accounting for effects of dm vs afdm differences, and random effects to take care of individual series-level correlation) to estimate a global trend

For each of these models, we can choose distributional assumptions via AIC/residuals

```{r Ni Distro comparison}

Ni_1 <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "identity"),select = TRUE) 

Ni_2 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 


Ni_3 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

Ni_4 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m=2,bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "identity"),select = TRUE) 

Ni_5 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"),
                   method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

Ni_6 <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m=2,bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = Gamma(link = "log"),select = TRUE) 


#model comparison and evaluation
Ni_names<-list(Ni_1,Ni_2,Ni_3,Ni_4,Ni_5,Ni_6)
map(Ni_names, ~AIC(.)) #best is 2 
map(Ni_names, ~appraise(.)) #not amazing, but hard to do anything else, and not many better options
summary(Ni_2) 

base_loc_mod <- Ni_2 #set best model to easier name to remember for later comparisons


#plot predictions
base_loc.pred<-predict_gam(type = "link", base_loc_mod, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_N = c(0.3,0.6,1.0,1.5,2.0,3,3.5)))%>%
  mutate(initial_N = as_factor(initial_N))


 base_loc.p<- ggplot()+
  geom_point(data = det_loc, aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = base_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 base_loc.p

 


```


When we're trying to ignore the differences in mass category, we'll sort of ignore this. But note the pretty significant differences here. DM samples really seem to have elevated N mass in later decomp compared to afdm samples. That's an interesting result in itself, but maybe more for a pure mass loss focused study (which we should totally do), but emphasis here is on controlling for that issue to explore N and P time series.

General process here is, for each environmental covariate
1) Fit Full model and compare different distributional assumptions
2) Use best distro assumption to 
  a) compare models of different fixed effects that 'modulate' the previous N curves, inference on 'best'
  b) Fit model of just Nmass~covariate*mass loss (i.e., no initial N term)



For some of these factors, our models will basically be intractable, and we'll have to adjust our analysis or ignore the potential effect. That's fine in exploratory work, just have to keep tabs on it. 

##N mass ~ Temperature

```{r N mass vs Temperature - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


N_Ni_T1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re") , 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_T4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_T5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_T6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_T1, N_Ni_T2,N_Ni_T3,N_Ni_T4,N_Ni_T5,N_Ni_T6)
map(Ni_mod_names, ~AIC(.)) #2 clear best by AIC -997, with 
map(Ni_mod_names, ~appraise(.)) #2 more homoscedastic than others...

```
Take dsitributional assumption from mod 2 (gaussian with inverse link)
```{r N mass vs Temperature - covar only}
N_Ni_Tonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, Temperature_C, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_Tonly.pred<-predict_gam(type = "link", N_Ni_Tonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, Temperature_C = c(5,10,15,20)))%>%
   mutate(Temperature_C = as_factor(Temperature_C))
  


 N_Ni_Tonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(Temperature_C)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_Tonly.p
 
 summary(N_Ni_Tonly)

```
Interestingly, our MassXTemperature interaction is highly significant, but the plotted predictions really change almost nothing from the global smoother

```{r N mass vs Temperature - initial/covar interaction}
#N_Ni_T2 was best most complex model, no need to fit again, but copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

a) ti(initialN, Temp)
b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_T2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+    
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,Temperature_C, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 





map(list(N_Ni_T2,N_Ni_T2a,N_Ni_T2b,N_Ni_T2c,N_Ni_T2d), AIC)#1 and 4 are equivalent
map(list(N_Ni_T2,N_Ni_T2a,N_Ni_T2b,N_Ni_T2c,N_Ni_T2d), appraise)#1 and 4 are basically the same

N_Ni_T.pred<-predict_gam(type = "link", N_Ni_T2b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),Temperature_C = c(5,10,15,20)))%>%
   mutate(Temperature_C = as_factor(Temperature_C), initial_N = as_factor(initial_N))
  


 N_Ni_T.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(Temperature_C)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_T.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = Temperature_C))+
   facet_grid(initial_N~Temperature_C)+
   geom_ribbon(data = N_Ni_T.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_T.p
 
 summary(N_Ni_T2c)

```


Interesting. There appears to be good support for a Temperature effect on top of the N curves. The plots predict that the temperature has its strongest effects in early decomposition, where increasing temperature shifts immobilization peaks earlier in the decomposition period. Colder may lead to a longer period of leaching contributing more to the mass loss.








##N mass ~ TN
```{r N mass vs TN - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


N_Ni_TN1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_TN2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re") , 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_TN4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_TN5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_TN6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_TN1, N_Ni_TN2,N_Ni_TN3,N_Ni_TN4,N_Ni_TN5,N_Ni_TN6)
map(Ni_mod_names, ~AIC(.)) #2 a bit better than 6
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```
Take dsitributional assumption from mod 2 (gaussian with inverse link)
```{r N mass vs TN - covar only}
N_Ni_TNonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, TN_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_Tonly.pred<-predict_gam(type = "link", N_Ni_TNonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg))
  


 N_Ni_TNonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TNonly.p
 
 summary(N_Ni_TNonly)

```

```{r N mass vs TN - initial/covar interaction}
#N_Ni_TN2 was best most complex model, no need to fit again, but form copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

#a) ti(initialN, Temp)
#b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
#c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_TN2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+    
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,TN_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 




Ni_mod_names <-list(N_Ni_TN2,N_Ni_TN2a,N_Ni_TN2b,N_Ni_TN2c,N_Ni_TN2d)
map(Ni_mod_names, AIC)#3 best, but not really different than any except 5
map(Ni_mod_names, appraise)#2 (a) has very slightly better resids

N_Ni_T.pred<-predict_gam(type = "link", N_Ni_TN2a, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg), initial_N = as_factor(initial_N))
  


 N_Ni_TN.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_T.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = TN_approx_avg))+
   facet_grid(initial_N~TN_approx_avg)+
   geom_ribbon(data = N_Ni_T.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TN.p
 
 summary(N_Ni_TN2d)

```

Also interesting, looks like model can't pick up on any effect of external TN on shifting these curves.

##N mass ~ TP

```{r N mass vs TP - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


N_Ni_TP1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_TP2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re") , 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_TP4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_TP5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_TP6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_TP1, N_Ni_TP2,N_Ni_TP3,N_Ni_TP4,N_Ni_TP5,N_Ni_TP6)
map(Ni_mod_names, ~AIC(.)) #2 best
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```
Take dsitributional assumption from mod 2 (gaussian with inverse link)
```{r N mass vs TP - covar only}
N_Ni_TNonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, TP_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_Tonly.pred<-predict_gam(type = "link", N_Ni_TNonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg))
  


 N_Ni_TNonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TNonly.p
 
 summary(N_Ni_TNonly)

```
Interestingly, our MassXTemperature interaction is highly significant, but the plotted predictions really change almost nothing from the global smoother

```{r N mass vs TP - initial/covar interaction}
#N_Ni_TN2 was best most complex model, no need to fit again, but form copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

#a) ti(initialN, Temp)
#b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
#c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_TP2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+    
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 


N_Ni_TP2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,TP_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 




Ni_mod_names <-list(N_Ni_TP2,N_Ni_TP2a,N_Ni_TP2b,N_Ni_TP2c,N_Ni_TP2d)
map(Ni_mod_names, AIC)#5 (d) best, then 2
map(Ni_mod_names, appraise)#2 (a) has very slightly better resids

N_Ni_TP.pred<-predict_gam(type = "link", N_Ni_TP2b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),TP_approx_avg = c(50,100,300,500)))%>%
   mutate(TP_approx_avg = as_factor(TP_approx_avg), initial_N = as_factor(initial_N))
  


 N_Ni_TP.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(TP_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_TP.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = TP_approx_avg))+
   facet_grid(initial_N~TP_approx_avg)+
   geom_ribbon(data = N_Ni_TP.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TP.p
 
 summary(N_Ni_TP2b)

```
No significant effect of TP here.

##N mass~Velocity
```{r N mass vs Velocity - Distro}

#full model and second most complex model would not fit

N_Ni_vel1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_vel2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"),  
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_vel3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_vel5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_vel6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_vel1, N_Ni_vel2,N_Ni_vel3,N_Ni_vel4,N_Ni_vel5,N_Ni_vel6)
map(Ni_mod_names, ~AIC(.)) #3 best
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```
Take distributional assumption from mod 3 (gaussian with log link)
```{r N mass vs Velocity - covar only}
N_Ni_velonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, Velocity_m.s, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_velonly.pred<-predict_gam(type = "link", N_Ni_velonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, Velocity_m.s = c(0.15,0.25,0.4)))%>%
   mutate(Velocity_m.s = as_factor(Velocity_m.s))
  


 N_Ni_velonly.pred.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(Velocity_m.s)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_velonly.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = Velocity_m.s))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
N_Ni_velonly.pred.p
 
 summary(N_Ni_velonly)

```
Velocity looks like it has a significant singular effect here on the N loss curves. It could be an important driver of these functions, or it could be correlated with initial N.

```{r N mass vs Velocity - initial/covar interaction}
#full model and mod4 can not fit - mroe coefficients than data
#only fit fittable models

N_Ni_vel3a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel3b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel3c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 







Ni_mod_names <-list(N_Ni_vel3a,N_Ni_vel3b,N_Ni_vel3c)
map(Ni_mod_names, AIC)#2 (b) best
map(Ni_mod_names, appraise)#2 (b) probably best resids but none particularly good

N_Ni_vel3b.pred<-predict_gam(type = "link", N_Ni_vel3b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),Velocity_m.s = c(0.05,0.1,0.15,0.2,0.25,0.3,0.4)))%>%
   mutate(Velocity_m.s = as_factor(Velocity_m.s), initial_N = as_factor(initial_N))
  


 N_Ni_vel3b.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(Velocity_m.s)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_vel3b.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_N, linetype = Velocity_m.s))+
   facet_grid(initial_N~Velocity_m.s)+
   geom_ribbon(data = N_Ni_vel3b.pred, aes(x = Mass_per_loss, ymin = exp(fit - 2*se.fit), ymax = exp(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_vel3b.p
 
 summary(N_Ni_vel3b)

```
The changes here may suggest a positive effect on N immobilization at for low levels of velocity, but then at higher velocities the peaks become flatter, which may suggest an increasing control of fragmentation on N loss. Interesting to note the flattening is much sharper for lower-initial N litter.


##N percent analysis 
N% analysis is complete (I think) but was moved to old DetNut_NP_analysis, as N% is highly influenced by other components



##C:N analysis - deprecated but model form useful


```{r}
CN_base1 <- gam(data = det_loc, CN_ratio ~
                        te(Mass_per_loss, initial_CN, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE)+
                        s(series_index, Mass_per_loss, bs = "re") + s(series_index, bs = "re"), 
             method = "REML", family = gaussian(link = "log"), select = TRUE)


CN_base2 <- gam(data = det_loc, CN_ratio ~ 
                        te(Mass_per_loss, initial_CN, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re")+ s(series_index, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 




AIC(CN_base1, CN_base2) #base 1 slightly favored
map(list(CN_base1,CN_base2), appraise) #2 chosen due to less heteroscedastic resids, even if deltaAIC ~90

baseCN_loc.pred<-predict_gam(type = "link", CN_base2, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL, Remain_Mass_Category = NULL, initial_CN = c(25,40,50,70,90,110,140)))%>%
  mutate(initial_CN = as_factor(initial_CN))



 base_loc_CN.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(CN_ratio)), aes(Mass_per_loss, CN_ratio), alpha = 0.3)+
    geom_smooth(data = baseCN_loc.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_CN))+
    geom_abline(slope = -0.01, intercept = 1)+
    #geom_ribbon(data = base_loc.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    NULL
 base_loc_CN.p

```


```{r CN vs initial Lignin}
#not enough data to fit models - CN also correlated with initial Lignin, so that is complicated, too

CN_Li1 <- gam(data = det_loc, CN_ratio ~  
                        te(Mass_per_loss, initial_CN, m = 2)+
                 ti(Mass_per_loss, initial_Lignin, initial_CN, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 


CN_Li2 <- gam(data = det_loc, CN_ratio ~  
                        te(Mass_per_loss, initial_CN, m = 2)+
                 ti(Mass_per_loss, initial_Lignin, initial_CN, m =2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

CN_Li3 <- gam(data = det_loc, CN_ratio ~  
                        te(Mass_per_loss, initial_CN, m = 2)+
                 ti(Mass_per_loss, initial_Lignin, initial_CN, m =2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE), 
             method = "REML", family = Gamma(link = "log"),select = TRUE)




map(list(CN_Li1, CN_Li2),AIC) #1 is better
map(list(CN_Li1, CN_Li2), appraise) #heteroscedastic but not much to be done, as usual

summary(CN_Li1) #interaction highly significant

CN_Li_mod <- CN_Li1 


#plot predictions
CN_loc_Li.pred<-predict_gam(type = "link", CN_Li_mod, length_out = 5000, values = list(Remain_Mass_Category = NULL, initial_Lignin = c(5,15,30), initial_CN = c(20,40,60,80)))%>%
   mutate(initial_Lignin = as_factor(initial_Lignin),initial_CN = as_factor(initial_CN))



CN_loc_Li.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(initial_Lignin)), aes(Mass_per_loss, CN_ratio), alpha = 0.3)+
    geom_smooth(data = CN_loc_Li.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_CN, linetype = initial_Lignin))+
    geom_abline(slope = -0.01, intercept = 1)+
    #geom_ribbon(data = base_loc.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    NULL
 CN_loc_Li.p
```
What's happening here is that initial_Lignin is likely correlated with CN. Interestingly, temperature also is! This is sort of just a fluke but I think prevents us from evaluating whether Temperature has any effect apart from initial CN ratios.
```{r}

ggplot(det_loc, aes(x = initial_Lignin, y = initial_CN))+
  geom_point()+
  geom_smooth(method = "lm")

ggplot(det_loc, aes(x = Temperature_C, y = initial_CN))+
  geom_point()+
  geom_smooth(method = "lm")

ggplot(det_loc%>%filter(TP_approx_avg <300), aes(x = TP_approx_avg, y = initial_CN))+
  geom_point()+
  geom_smooth(method = "lm")

```

##CN ~ Temperature

```{r CN vs Temperature - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


CN_Ni_T1 <- gam(data = det_loc, CN_ratio ~  
                        ti(initial_CN,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_CN, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_CN, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 


CN_Ni_T2 <- gam(data = det_loc, CN_ratio ~  
                        ti(initial_CN,Temperature_C, m = 2)+   
                        ti(Mass_per_loss,Temperature_C, m = 2)+  
                        ti(Mass_per_loss, initial_CN, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_CN, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 



CNi_mod_names <- list(CN_Ni_T1, CN_Ni_T2)
map(CNi_mod_names, ~AIC(.)) #1 slightly better 
map(CNi_mod_names, ~appraise(.)) #residuals on Gamma are better, going with 2

```

Take distributional assumption from mod 2 (Gamma)
```{r CN vs Temperature - covar only}
CN_Ni_Tonly <- gam(data = det_loc, CN_ratio ~  
                     te(Mass_per_loss, Temperature_C, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re")+s(series_index, bs = "re"), 
                   method = "REML", family = Gamma(link = "log"),select = TRUE) 

CN_Ni_Tonly.pred<-predict_gam(type = "link", CN_Ni_Tonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, Temperature_C = c(5,10,15,20)))%>%
   mutate(Temperature_C = as_factor(Temperature_C))
  


 CN_Ni_Tonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(Temperature_C)), aes(Mass_per_loss, CN_ratio), alpha = 0.3)+
    geom_smooth(data = CN_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 CN_Ni_Tonly.p
 
 summary(N_Ni_Tonly)

```


```{r CN vs Temperature - initial/covar interaction}
#N_Ni_T2 was best most complex model, no need to fit again, but copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

a) ti(initialN, Temp)
b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_T2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Temperature_C, m = 2)+    
                        ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_T2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,Temperature_C, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 





map(list(N_Ni_T2,N_Ni_T2a,N_Ni_T2b,N_Ni_T2c,N_Ni_T2d), AIC)#1 and 4 are equivalent
map(list(N_Ni_T2,N_Ni_T2a,N_Ni_T2b,N_Ni_T2c,N_Ni_T2d), appraise)#1 and 4 are basically the same

N_Ni_T.pred<-predict_gam(type = "link", N_Ni_T2b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),Temperature_C = c(5,10,15,20)))%>%
   mutate(Temperature_C = as_factor(Temperature_C), initial_N = as_factor(initial_N))
  


 N_Ni_T.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(Temperature_C)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_T.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = Temperature_C))+
   facet_grid(initial_N~Temperature_C)+
   geom_ribbon(data = N_Ni_T.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_T.p
 
 summary(N_Ni_T2c)

```


Interesting. There appears to be good support for a Temperature effect on top of the N curves. The plots predict that the temperature has its strongest effects in early decomposition, where increasing temperature shifts immobilization peaks earlier in the decomposition period. Colder may lead to a longer period of leaching contributing more to the mass loss.


##CN ~ TN
```{r CN vs TN - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


N_Ni_TN1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_TN2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re") , 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_TN4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_TN5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_TN6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TN_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_TN1, N_Ni_TN2,N_Ni_TN3,N_Ni_TN4,N_Ni_TN5,N_Ni_TN6)
map(Ni_mod_names, ~AIC(.)) #2 a bit better than 6
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```


```{r CN vs TN - covar only}
N_Ni_TNonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, TN_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_Tonly.pred<-predict_gam(type = "link", N_Ni_TNonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg))
  


 N_Ni_TNonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TNonly.p
 
 summary(N_Ni_TNonly)

```

```{r CN vs TN - initial/covar interaction}
#N_Ni_TN2 was best most complex model, no need to fit again, but form copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

#a) ti(initialN, Temp)
#b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
#c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_TN2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TN_approx_avg, m = 2)+    
                        ti(Mass_per_loss, initial_N, TN_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TN2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,TN_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 




Ni_mod_names <-list(N_Ni_TN2,N_Ni_TN2a,N_Ni_TN2b,N_Ni_TN2c,N_Ni_TN2d)
map(Ni_mod_names, AIC)#3 best, but not really different than any except 5
map(Ni_mod_names, appraise)#2 (a) has very slightly better resids

N_Ni_T.pred<-predict_gam(type = "link", N_Ni_TN2a, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg), initial_N = as_factor(initial_N))
  


 N_Ni_TN.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_T.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = TN_approx_avg))+
   facet_grid(initial_N~TN_approx_avg)+
   geom_ribbon(data = N_Ni_T.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TN.p
 
 summary(N_Ni_TN2d)

```

Also interesting, looks like model can't pick up on any effect of external TN on shifting these curves.

##CN ~ TP

```{r CN vs TP - Distro}

#fit full model on multiple link functions, then compare potential fixed effect structures with AIC


N_Ni_TP1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_TP2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re") , 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_TP4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_TP5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_TP6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+   
                        ti(Mass_per_loss,TP_approx_avg, m = 2)+  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_TP1, N_Ni_TP2,N_Ni_TP3,N_Ni_TP4,N_Ni_TP5,N_Ni_TP6)
map(Ni_mod_names, ~AIC(.)) #2 best
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```


```{r CN vs TP - covar only}
N_Ni_TNonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, TP_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_Tonly.pred<-predict_gam(type = "link", N_Ni_TNonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, TN_approx_avg = c(300,700,1500)))%>%
   mutate(TN_approx_avg = as_factor(TN_approx_avg))
  


 N_Ni_TNonly.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(TN_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_Tonly.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = Temperature_C))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TNonly.p
 
 summary(N_Ni_TNonly)

```


```{r CN vs TP - initial/covar interaction}
#N_Ni_TN2 was best most complex model, no need to fit again, but form copied here as reminder

#N_Ni_T2 <- gam(data = det_loc, N_mass_norm ~  
#                        ti(initial_N,Temperature_C, m = 2)+   
#                        ti(Mass_per_loss,Temperature_C, m = 2)+  
##                      ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#                        te(Mass_per_loss, initial_N, m = 2)+
#                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
#                        s(series_index, Mass_per_loss, bs = "re"), 
#             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

#a) ti(initialN, Temp)
#b) ti(Mass_per_loss, initial_N, Temperature_C, m = 2)
#c) ti(initial_N,Temperature_C, m = 2)+   ti(Mass_per_loss, initial_N, Temperature_C, m = 2)+
#d)te(Mass_per_loss, initial_N,Temperature_C, m = 2)+

N_Ni_TP2a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP2b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_TP2c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,TP_approx_avg, m = 2)+    
                        ti(Mass_per_loss, initial_N, TP_approx_avg, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 


N_Ni_TP2d <- gam(data = det_loc, N_mass_norm ~  
                        te(Mass_per_loss, initial_N,TP_approx_avg, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 




Ni_mod_names <-list(N_Ni_TP2,N_Ni_TP2a,N_Ni_TP2b,N_Ni_TP2c,N_Ni_TP2d)
map(Ni_mod_names, AIC)#5 (d) best, then 2
map(Ni_mod_names, appraise)#2 (a) has very slightly better resids

N_Ni_TP.pred<-predict_gam(type = "link", N_Ni_TP2b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),TP_approx_avg = c(50,100,300,500)))%>%
   mutate(TP_approx_avg = as_factor(TP_approx_avg), initial_N = as_factor(initial_N))
  


 N_Ni_TP.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(TP_approx_avg)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_TP.pred, se = FALSE, aes(x = Mass_per_loss, y = 1/fit, color = initial_N, linetype = TP_approx_avg))+
   facet_grid(initial_N~TP_approx_avg)+
   geom_ribbon(data = N_Ni_TP.pred, aes(x = Mass_per_loss, ymin = 1/(fit - 2*se.fit), ymax = 1/(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_TP.p
 
 summary(N_Ni_TP2b)

```
No significant effect of TP here.

##CN~Velocity
```{r CN vs Velocity - Distro}

#full model and second most complex model would not fit

N_Ni_vel1 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "identity"),select = TRUE) 

N_Ni_vel2 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"),  
             method = "REML", family = gaussian(link = "inverse"),select = TRUE) 

N_Ni_vel3 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel4 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "identity"),select = TRUE) 

N_Ni_vel5 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "inverse"),select = TRUE) 

N_Ni_vel6 <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = Gamma(link = "log"),select = TRUE) 

Ni_mod_names <- list(N_Ni_vel1, N_Ni_vel2,N_Ni_vel3,N_Ni_vel4,N_Ni_vel5,N_Ni_vel6)
map(Ni_mod_names, ~AIC(.)) #3 best
map(Ni_mod_names, ~appraise(.)) #2 better resids than 6

```


```{r CN vs Velocity - covar only}
N_Ni_velonly <- gam(data = det_loc, N_mass_norm ~  
                     te(Mass_per_loss, Velocity_m.s, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category,m=2, bs = c("tp", "re"), full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
                   method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_velonly.pred<-predict_gam(type = "link", N_Ni_velonly, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, Velocity_m.s = c(0.15,0.25,0.4)))%>%
   mutate(Velocity_m.s = as_factor(Velocity_m.s))
  


 N_Ni_velonly.pred.p<- ggplot()+
  geom_point(data = det_loc%>%filter(!is.na(Velocity_m.s)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_velonly.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = Velocity_m.s))+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
N_Ni_velonly.pred.p
 
 summary(N_Ni_velonly)

```


```{r CN vs Velocity - initial/covar interaction}
#full model and mod4 can not fit - mroe coefficients than data
#only fit fittable models

N_Ni_vel3a <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel3b <- gam(data = det_loc, N_mass_norm ~  
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 

N_Ni_vel3c <- gam(data = det_loc, N_mass_norm ~  
                        ti(initial_N,Velocity_m.s, m = 2)+    
                        ti(Mass_per_loss, initial_N, Velocity_m.s, m = 2)+
                        te(Mass_per_loss, initial_N, m = 2)+
                        t2(Mass_per_loss,Remain_Mass_Category, m = 2, bs = c("tp", "re"),full = TRUE) +
                        s(series_index, Mass_per_loss, bs = "re"), 
             method = "REML", family = gaussian(link = "log"),select = TRUE) 







Ni_mod_names <-list(N_Ni_vel3a,N_Ni_vel3b,N_Ni_vel3c)
map(Ni_mod_names, AIC)#2 (b) best
map(Ni_mod_names, appraise)#2 (b) probably best resids but none particularly good

N_Ni_vel3b.pred<-predict_gam(type = "link", N_Ni_vel3b, length_out = 5000,  exclude_terms = c("s(series_index)", "s(series_index, Mass_per_loss)"), values = list(series_index = NULL,Remain_Mass_Category = NULL, initial_N = c(0.4,1.0,1.5,2.0),Velocity_m.s = c(0.05,0.1,0.15,0.2,0.25,0.3,0.4)))%>%
   mutate(Velocity_m.s = as_factor(Velocity_m.s), initial_N = as_factor(initial_N))
  


 N_Ni_vel3b.p<- ggplot()+
  #geom_point(data = det_loc%>%filter(!is.na(Velocity_m.s)), aes(Mass_per_loss, N_mass_norm), alpha = 0.3)+
    geom_smooth(data = N_Ni_vel3b.pred, se = FALSE, aes(x = Mass_per_loss, y = exp(fit), color = initial_N, linetype = Velocity_m.s))+
   facet_grid(initial_N~Velocity_m.s)+
   geom_ribbon(data = N_Ni_vel3b.pred, aes(x = Mass_per_loss, ymin = exp(fit - 2*se.fit), ymax = exp(fit + 2*se.fit)), alpha = 0.3)+
    geom_abline(slope = -0.01, intercept = 1)+
    NULL
 N_Ni_vel3b.p
 
 summary(N_Ni_vel3b)

```