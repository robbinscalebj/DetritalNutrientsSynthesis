---
title: "DetNut_Data_Summary"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width = 3, fig.height = 2)
library(tidyverse)
library(magrittr)
library(datawizard)
```

```{r read datafile, include = FALSE, message = FALSE, warning = FALSE}


det <- read_csv("C:\\Users\\robbi\\Dropbox\\Detrital Nutrients Synth\\DetNutSynth_Database.csv")


```


```{r create new summary variables, include=FALSE}
det2 <- det%>%
  group_by(First_Author, Publication_Title, Time_Series_ID)%>%
  mutate(series_index = group_indices())%>%#creates a unique index for each time series
  ungroup()%>%
  group_by(series_index)%>% #functionally, used to confine any window functions like first() to a time series rather than the first observation of whole dataframe
  mutate(initial_C = first(C_per),
         initial_N = first(N_per),
         initial_P = first(P_per),
         initial_CN = first(CN_ratio),
         initial_CP = first(CP_ratio),
         initial_NP = first(NP_ratio),
         initial_Lignin = first(Lignin_per))%>%
  #next normalizes CNP values to initial measurements for each time series and to initial masses as in Manzoni
  mutate(C_prop_initial = C_per/first(C_per),
         N_prop_initial = N_per/first(N_per),
         P_prop_initial = P_per/first(P_per),
         C_mass_norm = ((C_per/100)*Mass_per_remaining)/(first(C_per/100)*first(Mass_per_remaining)),
         N_mass_norm = ((N_per/100)*Mass_per_remaining)/(first(N_per/100)*first(Mass_per_remaining)),
         P_mass_norm = ((P_per/100)*Mass_per_remaining)/(first(P_per/100)*first(Mass_per_remaining)))%>%
  #fill in any places where ratios could have been calculated, but weren't

  #next approximates percent mass remaining (if not provided) at each measurement day from k value
  mutate(Mass_per_remaining = case_when(is.na(Mass_per_remaining) & Remain_Mass_Category == "afdm" ~ exp(-k*Meas_Day)*100,
                                        is.na(Mass_per_remaining) & Remain_Mass_Category == "dm" ~ exp(-k*Meas_Day)*100,
                                        TRUE ~ Mass_per_remaining))%>%
  #next develops an approximation of N and P availability - imperfect, but aggregates the N and P data together about as well as possible without assuming anything else
  mutate(Water_DIN_ug.L = case_when(is.na(Water_DIN_ug.L) & is.na(Water_NH4_ug.L) ~ Water_NO3_ug.L,
                                    is.na(Water_DIN_ug.L) ~ Water_NO3_ug.L + Water_NH4_ug.L,
                                    TRUE ~ Water_DIN_ug.L),
         TN_approx = case_when(is.na(Water_TN_ug.L) ~ Water_DIN_ug.L,
                               TRUE ~ Water_TN_ug.L),
         TP_approx = case_when(is.na(Water_TP_ug.L) ~ Water_SRP_ug.L,
                               TRUE ~ Water_TP_ug.L))%>%
  #next creates a Temperature, TN, and TP average when there are multiple values given - these NEEDS TO BE CHANGED INTO A TIME-WEIGHTED AVERAGE
  mutate(Temperature_C_avg = case_when(n_distinct(Temperature_C) >1 ~ mean(Temperature_C), 
                                       TRUE ~ Temperature_C),
         TN_approx_avg = case_when(n_distinct(TN_approx) >1 ~ mean(TN_approx), 
                                       TRUE ~ TN_approx),
         TP_approx_avg = case_when(n_distinct(TP_approx) >1 ~ mean(TP_approx), 
                                       TRUE ~ TP_approx))%>%
  mutate(Deg_days = Temperature_C * (Meas_Day-first(Meas_Day)))%>% #degree days
  #remove text from variable if not coarse fine or open

  mutate(mesh_cat = case_when(Mesh_Size_Category == "coarse" | Mesh_Size_Category == "fine" | Mesh_Size_Category == "open" ~ Mesh_Size_Category,
                              Mesh_Size_Category < 1 ~ "fine",
                              Mesh_Size_Category >= 1 ~ "coarse"))%>%
 
  mutate(Lotic_Lentic = case_when(System == "stream"|System == "Stream"|System == "Channel"|System == "river" ~ "Lotic",
                                  System == "wetland"|System == "Wetland"|System == "wetlands"|System == "marsh"|System == "lake"|System == "Lake"|System == "pond"|System == "reservoir" ~ "Lentic",
                                  TRUE ~ System),
         Lotic_Lentic = as_factor(Lotic_Lentic))%>%

  mutate(cum_TN = cumsum(TN_approx_avg)*Meas_Day,
         cum_TP = cumsum(TP_approx_avg)*Meas_Day)%>%
  mutate(series_index = as_factor(series_index),
         Mass_per_loss = 100-(Mass_per_remaining),
         mesh_cat = as_factor(mesh_cat),
         Remain_Mass_Category = as_factor(Remain_Mass_Category))


#Time-integrated conditions - already calculated degree days, but could do to approximate a cumulative N load, P load, etc.

```


```{r summarize data distributions for numeric variables}
det_distros<-det2%>%
  discard(~!is.numeric(.))%>% #keeps only numeric variables
describe_distribution()%>%
  slice(1:31)%>% #keeps the main recorded vars/excludes lots of the 'created' or summarized variables from earlier chunk
  filter(Variable != "Publication_Year"&Variable != "Time_Series_ID")
det_distros
```
Notes:
-Some very high nutrient values (e.g., Gamage et al nitrogen) can be recorded in beaker studies where water isn't replaced



```{r histogram contrinuous variables,message = FALSE, warning = FALSE}
#extract row names
det_names <- det_distros%>%
  pull(Variable)

histo.f<-function(x){
  ggplot(det2, aes(.data[[x]]))+
    geom_histogram()
}

map(det_names, histo.f)

```

```{r summarize  character variables}
det_chars<-det2%>%
  discard(~is.numeric(.))%>% #excludes numeric variables
  #then this should use a tidy version of unique to look at the unique levels for many of the variables that are not descriptive, which can be filtered out
 map(fct_count)
  
det_chars
```

```{r}
det.x <- det2%>%filter(Initial_Mass_g>400)

```



```{r aggregated summaries}
#this will create a nested dataframe (the data are included as a column within the larger dataframe) that can be used to look at characteristics of each time series, rather than the  data overall. This may have limited application, but can also be expanded.

DetNut.nest <- det2%>%
  group_by(First_Author, Publication_Title, Journal, series_index)%>%
  nest()%>%
  mutate(System = map_chr(data, ~first(.$System)),
         Lotic_Lentic = map_chr(data, ~first(.$Lotic_Lentic)),
         Detritus_Condition = map_chr(data, ~first(.$Detritus_Condition)),
         Detritus_Species = map_chr(data, ~first(.$Detritus_Species)),
         Detritus_Type = map_chr(data, ~first(.$Detritus_Type)),
         Decay_Method = map_chr(data, ~first(.$Decay_Method)),
         initial_C = map_dbl(data, ~first(.$initial_C)),
         initial_N = map_dbl(data, ~first(.$initial_N)),
         initial_P = map_dbl(data, ~first(.$initial_P)),
         initial_CN = map_dbl(data, ~first(.$initial_CN)),
         initial_CP = map_dbl(data, ~first(.$initial_CP)),
         initial_NP = map_dbl(data, ~first(.$initial_NP)),
         initial_Lignin = map_dbl(data, ~first(.$initial_Lignin)))%>%
  #count observations per series
  mutate(Series_Measurements = map_dbl(data, nrow),
         C_counts = map_dbl(data, ~sum(!is.na(.$C_per))),
         N_counts = map_dbl(data, ~sum(!is.na(.$N_per))),
         P_counts = map_dbl(data, ~sum(!is.na(.$P_per))),
         CN_counts = map_dbl(data, ~sum(!is.na(.$CN_ratio))),
         CP_counts = map_dbl(data, ~sum(!is.na(.$CP_ratio))),
         NP_counts = map_dbl(data, ~sum(!is.na(.$NP_ratio))))


```



```{r}
DetNut_species<- det2%>%
  ungroup()%>%
  summarize(n_species = n_distinct(Detritus_Species))

DetNut_types<- det2%>%
  ungroup()%>%
  count(Detritus_Type)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

DetNut_systems<- det2%>%
  ungroup()%>%
  count(System)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

DetNut_lotlentype<- det2%>%
   ungroup()%>%
  filter(Lotic_Lentic == "Lotic"|Lotic_Lentic == "Lentic")%>%
  count(Lotic_Lentic, Detritus_Type)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

DetNut_lotlen<- det2%>%
  ungroup()%>%
  filter(Lotic_Lentic == "Lotic"|Lotic_Lentic == "Lentic")%>%
  count(Lotic_Lentic)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))


DetNut_systemstypes<- det2%>%
  ungroup()%>%
  count(System, Detritus_Type)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))
 
DetNut_systemstypescond<- det2%>%
  ungroup()%>%
  count(System, Detritus_Type, Detritus_Condition)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

 
DetNut_typescond<- det2%>%
  ungroup()%>%
  count(Detritus_Type, Detritus_Condition)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

DetNut_taxa<- det2%>%
  ungroup()%>%
  count(Detritus_Species)%>%
  mutate(proportion = n/sum(n))%>%
  arrange(desc(proportion))

DetNut_species
DetNut_types
DetNut_systems
DetNut_lotlentype
DetNut_lotlen
DetNut_systemstypes
DetNut_systemstypescond
DetNut_typescond

```





